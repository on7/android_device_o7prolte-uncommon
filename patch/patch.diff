diff -ur a/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java b/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java
--- a/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java	Wed Apr 20 08:50:20 2016
+++ b/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java	Thu May 12 01:31:40 2016
@@ -48,6 +48,8 @@
 import android.telecom.PhoneAccountHandle;
 import android.telecom.TelecomManager;
 import android.telecom.VideoProfile;
+import android.telecom.PhoneAccountHandle;
+import android.telephony.SubscriptionManager;
 import android.telephony.PhoneNumberUtils;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
@@ -236,6 +238,8 @@
     private DsdaAdapter mDsdaAdapter = null;
 
     private HashMap<String, Boolean> mLchStatus = new HashMap<String, Boolean>();
+	
+	private AudioManager mAudioManager;
 
     // Two global variables used to handle the Emergency Call when there
     // is no room available for emergency call. Buffer the Emergency Call
@@ -339,6 +343,8 @@
         mListeners.add(mHeadsetMediaButton);
         mListeners.add(mProximitySensorManager);
         mListeners.add(mViceNotificationImpl);
+		
+		mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
 
         // There is no USER_SWITCHED broadcast for user 0, handle it here explicitly.
         final UserManager userManager = UserManager.get(mContext);
@@ -347,6 +353,58 @@
             onUserSwitch(Process.myUserHandle());
         }
     }
+	
+	private int getPhoneId(Call call) {
+        if (call.getTargetPhoneAccount() != null) {
+            PhoneAccountHandle account = call.getTargetPhoneAccount();
+            try {
+               int index = Integer.parseInt(account.getId());
+                int phoneId = SubscriptionManager.getPhoneId(index);
+                if (SubscriptionManager.isValidPhoneId(phoneId)) {
+                     return phoneId;
+                }
+            } catch (NumberFormatException e) {
+                Log.e(this, e, "Cannot get phoneId from ID value " + account.getId());
+            }
+        }
+        return -1;
+    }
+	
+	private void setMSIMAudio(int oldState, int newState) {
+		Log.i(this, "setMSIMAudio %s -> %s", CallState.toString(oldState), CallState.toString(newState));
+		int mPhoneID = 0;
+		if(oldState == CallState.RINGING && newState == CallState.ACTIVE){
+			Log.i(this, "setMSIMAudio INCOMING CALL");
+			mPhoneID = getPhoneId(getForegroundCall());
+			if(mPhoneID == 0){
+				Log.i(this, "setMSIMAudio INCOMING CALL CP1");
+				mAudioManager.setParameters("phone_type=cp1");	
+			}else if (mPhoneID == 1){
+				Log.i(this, "setMSIMAudio INCOMING CALL CP2");
+				mAudioManager.setParameters("phone_type=cp2");	
+			}
+			Log.i(this, "setMSIMAudio INCOMING CALL REALCALL ON");
+			mAudioManager.setParameters("realcall=on");
+		}else if(oldState == CallState.DIALING && newState == CallState.DIALING){ /* OUTCALL */
+			Log.i(this, "setMSIMAudio OUT CALL");
+			mPhoneID = getPhoneId(getForegroundCall());
+			if(mPhoneID == 0){
+				Log.i(this, "setMSIMAudio OUT CALL CP1");
+				mAudioManager.setParameters("phone_type=cp1");	
+			}else if (mPhoneID == 1){
+				Log.i(this, "setMSIMAudio OUT CALL CP2");
+				mAudioManager.setParameters("phone_type=cp2");		
+			}
+			Log.i(this, "setMSIMAudio OUT CALL REALCALL ON");
+			mAudioManager.setParameters("realcall=on");
+		}else if(newState == CallState.DISCONNECTED){
+			Log.i(this, "setMSIMAudio DISCONNECTED OUT CALL REALCALL OFF");
+			mAudioManager.setParameters("realcall=off");
+		}else if(newState == CallState.ABORTED){
+			Log.i(this, "setMSIMAudio ABORTED OUT CALL REALCALL OFF");
+			mAudioManager.setParameters("realcall=off");
+		}
+    }
 
     ViceNotificationImpl getViceNotificationImpl() {
         return mViceNotificationImpl;
@@ -2075,6 +2133,9 @@
             Trace.endSection();
         }
         manageDsdaInCallTones(false);
+		if (call != null) {
+			setMSIMAudio(oldState, newState);
+		}
     }
 
     private void updateCanAddCall() {

diff -ur a/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java b/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java
--- a/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java	Mon Jun 20 17:28:46 2016
+++ b/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java	Mon Jun 27 10:45:01 2016
@@ -60,6 +60,8 @@
 import com.android.server.SystemService;
 import com.android.server.UiThread;
 
+import java.io.FileOutputStream;
+import java.io.IOException;
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -224,6 +226,8 @@
     // Only used by requestDisplayState.  The field is self-synchronized and only
     // intended for use inside of the requestGlobalDisplayStateInternal function.
     private final ArrayList<Runnable> mTempDisplayStateWorkQueue = new ArrayList<Runnable>();
+	
+	public static final String TS_PATH = "/sys/class/input/input3/enabled";
 
     public DisplayManagerService(Context context) {
         super(context);
@@ -707,6 +711,36 @@
         }
         scheduleTraversalLocked(false);
     }
+	
+	// Writes to sysfs node, returns true if success, false if fail
+     private boolean write_sysfs(String path, boolean on) {
+        try {
+            FileOutputStream fos = new FileOutputStream(path);
+            byte[] bytes = new byte[2];
+            bytes[0] = (byte)(on ? '1' : '0');
+            bytes[1] = '\n';
+            fos.write(bytes);
+            fos.close();
+        } catch (Exception e) {
+            Slog.i(TAG, "Fail: " + e.getLocalizedMessage());
+            return false;
+        }
+        return true;
+    }
+	
+	// Enables or disables input devices by writing to sysfs path
+    private void enableDevices(boolean enable) {
+        boolean ret;
+        if(enable) {
+            // Turn on touch input
+            ret = write_sysfs(TS_PATH, true);
+            Slog.i(TAG, "Enabled touchscreen, success? " + ret);
+        } else {
+            // Turn off touch input
+            ret = write_sysfs(TS_PATH, false);
+            Slog.i(TAG, "Disabled touchscreen, success? " + ret);
+        }
+    }
 
     private void handleDisplayDeviceChanged(DisplayDevice device) {
         synchronized (mSyncRoot) {
@@ -720,6 +754,12 @@
             if (diff == DisplayDeviceInfo.DIFF_STATE) {
                 Slog.i(TAG, "Display device changed state: \"" + info.name
                         + "\", " + Display.stateToString(info.state));
+				if(info.state == Display.STATE_ON){
+					enableDevices(true);
+				}
+				if (info.state == Display.STATE_OFF) {
+					enableDevices(false);
+				}		
             } else if (diff != 0) {
                 Slog.i(TAG, "Display device changed: " + info);
             }

diff -ur a/hardware/qcom/fm/fmapp2/src/com/caf/fmradio/FMRadioService.java b/hardware/qcom/fm/fmapp2/src/com/caf/fmradio/FMRadioService.java
--- a/hardware/qcom/fm/fmapp2/src/com/caf/fmradio/FMRadioService.java	Mon Jun 20 17:28:46 2016
+++ b/hardware/qcom/fm/fmapp2/src/com/caf/fmradio/FMRadioService.java	Mon Jun 27 10:45:01 2016
@@ -1066,14 +1066,25 @@
                mSpeakerPhoneOn = true;
                Log.d(LOGTAG, "Audio source set it as speaker");
                AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_SPEAKER);
+			   mAudioManager.setParameters("fm_mode=on");
+               mAudioManager.setParameters("fm_radio_volume=on");
+               mAudioManager.setParameters("FMRadioVol=0.1496235728");
+               mAudioManager.setMode(AudioManager.MODE_IN_CALL);
+               mAudioManager.setSpeakerphoneOn(true);
            } else {
                Log.d(LOGTAG, "Audio source set it as headset");
                AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_NONE);
+			   mAudioManager.setParameters("fm_mode=on");
+               mAudioManager.setParameters("fm_radio_volume=on");
+               mAudioManager.setParameters("FMRadioVol=0.1496235728");
+               mAudioManager.setMode(AudioManager.MODE_IN_CALL);
+               mAudioManager.setSpeakerphoneOn(false);
            }
        } else {
                Log.d(LOGTAG, "A2DP is connected, set audio source to A2DP HS");
                AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_SPEAKER);
                mSpeakerPhoneOn = true;
+			   mAudioManager.setSpeakerphoneOn(true);
        }
 
        mPlaybackInProgress = true;
@@ -1090,6 +1101,8 @@
        Log.d(LOGTAG, "In stopFM");
        configureAudioDataPath(false);
        mPlaybackInProgress = false;
+	   mAudioManager.setParameters("fm_radio_mute=1");
+       mAudioManager.setParameters("fm_mode=off");
        try {
            if ((mServiceInUse) && (mCallbacks != null))
                mCallbacks.onFmAudioPathStopped();
@@ -1539,6 +1552,7 @@
       public void run() {
          Log.v(LOGTAG, "Disabling Speaker");
          AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_NONE);
+		 mAudioManager.setSpeakerphoneOn(false);
       }
    };
 
@@ -2257,6 +2271,7 @@
       if ( mSpeakerPhoneOn) {
           mSpeakerPhoneOn = false;
           AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_NONE);
+		  mAudioManager.setSpeakerphoneOn(false);
       }
    }
 
@@ -2376,10 +2391,12 @@
             } else {
                 Log.d(LOGTAG, "A2DP is not connected, force none");
                 AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_NONE);
+				mAudioManager.setSpeakerphoneOn(false);
             }
        } else if (speakerOn == true) {
            Log.d(LOGTAG, "enabling speaker");
            AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_SPEAKER);
+		   mAudioManager.setSpeakerphoneOn(true);
        }
 
        Log.d(LOGTAG, "speakerOn completed:" + speakerOn);
@@ -2480,6 +2497,7 @@
       {
          mMuted = true;
          audioManager.setParameters("fm_mute=1");
+		 audioManager.setParameters("fm_radio_mute=1");
          if (mAudioTrack != null)
              mAudioTrack.setVolume(0.0f);
       }
@@ -2502,6 +2520,7 @@
       {
          mMuted = false;
          audioManager.setParameters("fm_mute=0");
+		 audioManager.setParameters("fm_radio_mute=0");
          if (mAudioTrack != null)
              mAudioTrack.setVolume(1.0f);
          if (mResumeAfterCall)
