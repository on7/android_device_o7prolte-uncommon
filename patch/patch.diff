diff -ur a/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java b/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java
--- a/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java	Wed Apr 20 08:50:20 2016
+++ b/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java	Thu May 12 01:31:40 2016
@@ -86,6 +86,12 @@
 import org.codeaurora.ims.QtiCallConstants;
 import org.codeaurora.ims.utils.QtiImsExtUtils;
 import org.codeaurora.internal.IExtTelephony;
+
+import android.app.ActivityManagerNative;
+import android.os.Binder;
+import android.os.IBinder;
+import android.telephony.SubscriptionManager;
+import com.android.internal.util.Preconditions;
 /**
  * Singleton.
  *
@@ -233,6 +239,9 @@
 
     private HashMap<String, Boolean> mLchStatus = new HashMap<String, Boolean>();
 
+	private AudioManager mAudioManager;
+	boolean setMsimAudioParams;
+
     /**
      * Initializes the required Telecom components.
      */
@@ -314,6 +323,10 @@
                 new ConnectionServiceRepository(mPhoneAccountRegistrar, mContext, mLock, this);
         mInCallWakeLockController = inCallWakeLockControllerFactory.create(context, this);
         mViceNotificationImpl = viceNotifier.create(mContext, this);
+		
+		mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
+		
+		setMsimAudioParams = SystemProperties.getBoolean("ro.multisim.set_audio_params", false);
 
         mListeners.add(mInCallWakeLockController);
         mListeners.add(statusBarNotifier);
@@ -333,7 +346,23 @@
             onUserSwitch(Process.myUserHandle());
         }
     }
-
+	
+	private int getPhoneId(Call call) {
+         if (call.getTargetPhoneAccount() != null) {
+             PhoneAccountHandle account = call.getTargetPhoneAccount();
+            try {
+                 int index = Integer.parseInt(account.getId());
+                 int phoneId = SubscriptionManager.getPhoneId(index);
+                 if (SubscriptionManager.isValidPhoneId(phoneId)) {
+                     return phoneId;
+                 }
+             } catch (NumberFormatException e) {
+                 Log.e(this, e, "Cannot get phoneId from ID value " + account.getId());
+             }
+         }
+         return -1;
+    }
+	
     ViceNotificationImpl getViceNotificationImpl() {
         return mViceNotificationImpl;
     }
@@ -357,7 +386,15 @@
     @Override
     public void onSuccessfulOutgoingCall(Call call, int callState) {
         Log.v(this, "onSuccessfulOutgoingCall, %s", call);
-
+		Call callm = getForegroundCall();
+		if(setMsimAudioParams){
+			int phoneId = getPhoneId(callm);
+			if (phoneId == 0) {
+				mAudioManager.setParameters("phone_type=cp1");
+			} else if (phoneId == 1) {
+				mAudioManager.setParameters("phone_type=cp2");
+			}
+		}
         setCallState(call, callState, "successful outgoing call");
         if (!mCalls.contains(call)) {
             // Call was not added previously in startOutgoingCall due to it being a potential MMI
@@ -383,6 +420,15 @@
     @Override
     public void onSuccessfulIncomingCall(Call incomingCall) {
         Log.d(this, "onSuccessfulIncomingCall");
+		Call callm = getForegroundCall();
+		if(setMsimAudioParams){
+			int phoneId = getPhoneId(callm);
+			if (phoneId == 0) {
+				mAudioManager.setParameters("phone_type=cp1");
+			} else if (phoneId == 1) {
+				mAudioManager.setParameters("phone_type=cp2");
+			}
+		}
         List<IncomingCallFilter.CallFilter> filters = new ArrayList<>();
         filters.add(new DirectToVoicemailCallFilter(mCallerInfoLookupHelper));
         filters.add(new AsyncBlockCheckFilter(mContext, new BlockCheckerAdapter()));

diff -ur a/packages/services/Telecomm/src/com/android/server/telecom/CallAudioModeStateMachine.java b/packages/services/Telecomm/src/com/android/server/telecom/CallAudioModeStateMachine.java
--- a/packages/services/Telecomm/src/com/android/server/telecom/CallAudioModeStateMachine.java	Wed Apr 20 08:50:20 2016
+++ b/packages/services/Telecomm/src/com/android/server/telecom/CallAudioModeStateMachine.java	Thu May 12 01:31:40 2016
@@ -152,6 +152,7 @@
                 mAudioManager.setMode(AudioManager.MODE_NORMAL);
 
                 mMostRecentMode = AudioManager.MODE_NORMAL;
+				mAudioManager.setParameters("realcall=off");
                 mCallAudioManager.setCallAudioRouteFocusState(CallAudioRouteStateMachine.NO_FOCUS);
             }
         }
@@ -288,6 +289,7 @@
                     AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);
             mAudioManager.setMode(AudioManager.MODE_IN_CALL);
             mMostRecentMode = AudioManager.MODE_IN_CALL;
+			mAudioManager.setParameters("realcall=on");
             mCallAudioManager.setCallAudioRouteFocusState(CallAudioRouteStateMachine.HAS_FOCUS);
         }
 
diff -ur a/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java b/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java
--- a/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java	Mon Jun 20 17:28:46 2016
+++ b/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java	Mon Jun 27 10:45:01 2016
@@ -62,6 +62,8 @@
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
+import java.io.FileOutputStream;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -134,6 +136,8 @@
     private WindowManagerInternal mWindowManagerInternal;
     private InputManagerInternal mInputManagerInternal;
     private IMediaProjectionManager mProjectionService;
+	
+	public static final String TS_PATH = "/sys/class/input/input3/enabled";
 
     // The synchronization root for the display manager.
     // This lock guards most of the display manager's state.
@@ -697,6 +701,36 @@
         }
         scheduleTraversalLocked(false);
     }
+	
+	 // Writes to sysfs node, returns true if success, false if fail
+     private boolean write_sysfs(String path, boolean on) {
+        try {
+            FileOutputStream fos = new FileOutputStream(path);
+            byte[] bytes = new byte[2];
+            bytes[0] = (byte)(on ? '1' : '0');
+            bytes[1] = '\n';
+            fos.write(bytes);
+            fos.close();
+        } catch (Exception e) {
+            Slog.i(TAG, "Fail: " + e.getLocalizedMessage());
+            return false;
+        }
+        return true;
+    }
+	
+	// Enables or disables input devices by writing to sysfs path
+    private void enableDevices(boolean enable) {
+        boolean ret;
+        if(enable) {
+            // Turn on touch input
+            ret = write_sysfs(TS_PATH, true);
+            Slog.i(TAG, "Enabled touchscreen, success? " + ret);
+        } else {
+            // Turn off touch input
+            ret = write_sysfs(TS_PATH, false);
+            Slog.i(TAG, "Disabled touchscreen, success? " + ret);
+        }
+    }
 
     private void handleDisplayDeviceChanged(DisplayDevice device) {
         synchronized (mSyncRoot) {
@@ -710,6 +744,14 @@
             if (diff == DisplayDeviceInfo.DIFF_STATE) {
                 Slog.i(TAG, "Display device changed state: \"" + info.name
                         + "\", " + Display.stateToString(info.state));
+						
+				if(info.state == Display.STATE_ON){
+					enableDevices(true);
+				}
+				if (info.state == Display.STATE_OFF) {
+					enableDevices(false);
+				}		
+						
             } else if (diff != 0) {
                 Slog.i(TAG, "Display device changed: " + info);
             }
