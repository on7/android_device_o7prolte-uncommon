diff -ur a/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java b/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java
--- a/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java	Wed Apr 20 08:50:20 2016
+++ b/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java	Thu May 12 01:31:40 2016
@@ -195,6 +195,7 @@
     private final PhoneStateBroadcaster mPhoneStateBroadcaster;
     private final CallLogManager mCallLogManager;
     private final Context mContext;
+    public  final Context pContext;
     private final TelecomSystem.SyncRoot mLock;
     private final ContactsAsyncHelper mContactsAsyncHelper;
     private final CallerInfoAsyncQueryFactory mCallerInfoAsyncQueryFactory;
@@ -255,6 +256,7 @@
             AsyncRingtonePlayer asyncRingtonePlayer,
             ViceNotifier viceNotifier) {
         mContext = context;
+        pContext = context;
         mLock = lock;
         mContactsAsyncHelper = contactsAsyncHelper;
         mCallerInfoAsyncQueryFactory = callerInfoAsyncQueryFactory;

diff -ur a/packages/services/Telecomm/src/com/android/server/telecom/CallAudioModeStateMachine.java b/packages/services/Telecomm/src/com/android/server/telecom/CallAudioModeStateMachine.java
--- a/packages/services/Telecomm/src/com/android/server/telecom/CallAudioModeStateMachine.java	Wed Apr 20 08:50:20 2016
+++ b/packages/services/Telecomm/src/com/android/server/telecom/CallAudioModeStateMachine.java	Thu May 12 01:31:40 2016
@@ -24,6 +24,8 @@
 import com.android.internal.util.State;
 import com.android.internal.util.StateMachine;
 
+import android.os.SystemProperties;
+
 public class CallAudioModeStateMachine extends StateMachine {
     public static class MessageArgs {
         public boolean hasActiveOrDialingCalls;
@@ -60,6 +62,8 @@
                     '}';
         }
     }
+	
+	public int PHONE_ID = 0;
 
     public static final int INITIALIZE = 1;
     // These ENTER_*_FOCUS commands are for testing.
@@ -107,7 +111,8 @@
 
     public static final String TONE_HOLD_STATE_NAME = OtherFocusState.class.getSimpleName();
     public static final String UNFOCUSED_STATE_NAME = UnfocusedState.class.getSimpleName();
-    public static final String CALL_STATE_NAME = SimCallFocusState.class.getSimpleName();
+    public static final String CALL1_STATE_NAME = Sim1CallFocusState.class.getSimpleName();
+	public static final String CALL2_STATE_NAME = Sim2CallFocusState.class.getSimpleName();
     public static final String RING_STATE_NAME = RingingFocusState.class.getSimpleName();
     public static final String COMMS_STATE_NAME = VoipCallFocusState.class.getSimpleName();
 
@@ -116,7 +121,12 @@
         public boolean processMessage(Message msg) {
             switch (msg.what) {
                 case ENTER_CALL_FOCUS_FOR_TESTING:
-                    transitionTo(mSimCallFocusState);
+					if(PHONE_ID == 0){
+						transitionTo(mSim1CallFocusState);
+					} 
+					if(PHONE_ID == 1){
+						transitionTo(mSim2CallFocusState);
+					}
                     return HANDLED;
                 case ENTER_COMMS_FOCUS_FOR_TESTING:
                     transitionTo(mVoipCallFocusState);
@@ -173,8 +183,14 @@
                     // Do nothing.
                     return HANDLED;
                 case NEW_ACTIVE_OR_DIALING_CALL:
-                    transitionTo(args.foregroundCallIsVoip
-                            ? mVoipCallFocusState : mSimCallFocusState);
+					if(PHONE_ID == 0){
+						transitionTo(args.foregroundCallIsVoip
+                            ? mVoipCallFocusState : mSim1CallFocusState);
+					} 
+					if(PHONE_ID == 1){
+						transitionTo(args.foregroundCallIsVoip
+                            ? mVoipCallFocusState : mSim2CallFocusState);
+					}
                     return HANDLED;
                 case NEW_RINGING_CALL:
                     transitionTo(mRingingFocusState);
@@ -242,7 +258,12 @@
                         if (args.foregroundCallIsVoip) {
                             transitionTo(mVoipCallFocusState);
                         } else {
-                            transitionTo(mSimCallFocusState);
+                            if(PHONE_ID == 0){
+								transitionTo(mSim1CallFocusState);
+							} 
+							if(PHONE_ID == 1){
+								transitionTo(mSim2CallFocusState);
+							}
                         }
                     } else if (args.hasHoldingCalls || args.isTonePlaying) {
                         transitionTo(mOtherFocusState);
@@ -252,8 +273,14 @@
                     return HANDLED;
                 case NEW_ACTIVE_OR_DIALING_CALL:
                     // If a call becomes active suddenly, give it priority over ringing.
-                    transitionTo(args.foregroundCallIsVoip
-                            ? mVoipCallFocusState : mSimCallFocusState);
+					if(PHONE_ID == 0){
+						transitionTo(args.foregroundCallIsVoip
+                            ? mVoipCallFocusState : mSim1CallFocusState);		
+					}
+                    if(PHONE_ID == 1){
+						transitionTo(args.foregroundCallIsVoip
+                            ? mVoipCallFocusState : mSim2CallFocusState);		
+					}
                     return HANDLED;
                 case NEW_RINGING_CALL:
                     Log.w(LOG_TAG, "Unexpected behavior! New ringing call appeared while in " +
@@ -271,7 +298,12 @@
 
                     // VOIP calls should never invoke this mechanism, so transition directly to
                     // the sim call focus state.
-                    transitionTo(mSimCallFocusState);
+					if(PHONE_ID == 0){
+						transitionTo(mSim1CallFocusState);	
+					}
+                    if(PHONE_ID == 1){
+						transitionTo(mSim2CallFocusState);	
+					}
                     return HANDLED;
                 default:
                     // The forced focus switch commands are handled by BaseState.
@@ -280,7 +312,72 @@
         }
     }
 
-    private class SimCallFocusState extends BaseState {
+    private class Sim1CallFocusState extends BaseState {
+        @Override
+        public void enter() {
+            Log.i(LOG_TAG, "Audio focus entering SIM CALL state");
+            mAudioManager.requestAudioFocusForCall(AudioManager.STREAM_VOICE_CALL,
+                    AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);
+            mAudioManager.setMode(AudioManager.MODE_IN_CALL);
+            mMostRecentMode = AudioManager.MODE_IN_CALL;
+			mAudioManager.setParameters("phone_type=cp1");
+			mAudioManager.setParameters("realcall=on");
+            mCallAudioManager.setCallAudioRouteFocusState(CallAudioRouteStateMachine.HAS_FOCUS);
+			
+        }
+
+        @Override
+        public boolean processMessage(Message msg) {
+            if (super.processMessage(msg) == HANDLED) {
+                return HANDLED;
+            }
+            MessageArgs args = (MessageArgs) msg.obj;
+            switch (msg.what) {
+                case NO_MORE_ACTIVE_OR_DIALING_CALLS:
+                    // Switch to either ringing, holding, or inactive
+                    transitionTo(destinationStateAfterNoMoreActiveCalls(args));
+                    return HANDLED;
+                case NO_MORE_RINGING_CALLS:
+                    // Don't transition state, but stop any call-waiting tones that may have been
+                    // playing.
+                    if (args.isTonePlaying) {
+                        mCallAudioManager.stopCallWaiting();
+                    }
+                    // If a MT-audio-speedup call gets disconnected by the connection service
+                    // concurrently with the user answering it, we may get this message
+                    // indicating that a ringing call has disconnected while this state machine
+                    // is in the SimCallFocusState.
+                    if (!args.hasActiveOrDialingCalls) {
+                        transitionTo(destinationStateAfterNoMoreActiveCalls(args));
+                    }
+                    return HANDLED;
+                case NO_MORE_HOLDING_CALLS:
+                    // Do nothing.
+                    return HANDLED;
+                case NEW_ACTIVE_OR_DIALING_CALL:
+                    // Do nothing. Already active.
+                    return HANDLED;
+                case NEW_RINGING_CALL:
+                    // Don't make a call ring over an active call, but do play a call waiting tone.
+                    mCallAudioManager.startCallWaiting();
+                    return HANDLED;
+                case NEW_HOLDING_CALL:
+                    // Don't do anything now. Putting an active call on hold will be handled when
+                    // NO_MORE_ACTIVE_CALLS is processed.
+                    return HANDLED;
+                case FOREGROUND_VOIP_MODE_CHANGE:
+                    if (args.foregroundCallIsVoip) {
+                        transitionTo(mVoipCallFocusState);
+                    }
+                    return HANDLED;
+                default:
+                    // The forced focus switch commands are handled by BaseState.
+                    return NOT_HANDLED;
+            }
+        }
+    }
+	
+	private class Sim2CallFocusState extends BaseState {
         @Override
         public void enter() {
             Log.i(LOG_TAG, "Audio focus entering SIM CALL state");
@@ -288,6 +385,8 @@
                     AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);
             mAudioManager.setMode(AudioManager.MODE_IN_CALL);
             mMostRecentMode = AudioManager.MODE_IN_CALL;
+			mAudioManager.setParameters("phone_type=cp2");
+			mAudioManager.setParameters("realcall=on");
             mCallAudioManager.setCallAudioRouteFocusState(CallAudioRouteStateMachine.HAS_FOCUS);
         }
 
@@ -387,7 +486,12 @@
                     return HANDLED;
                 case FOREGROUND_VOIP_MODE_CHANGE:
                     if (!args.foregroundCallIsVoip) {
-                        transitionTo(mSimCallFocusState);
+						if(PHONE_ID == 0){
+							transitionTo(mSim1CallFocusState);	
+						}
+                        if(PHONE_ID == 1){
+							transitionTo(mSim2CallFocusState);	
+						}
                     }
                     return HANDLED;
                 default:
@@ -429,8 +533,14 @@
                     // Do nothing if a tone is playing.
                     return HANDLED;
                 case NEW_ACTIVE_OR_DIALING_CALL:
-                    transitionTo(args.foregroundCallIsVoip
-                            ? mVoipCallFocusState : mSimCallFocusState);
+					if(PHONE_ID == 0){
+						transitionTo(args.foregroundCallIsVoip
+                            ? mVoipCallFocusState : mSim1CallFocusState);	
+					}
+                    if(PHONE_ID == 1){
+						transitionTo(args.foregroundCallIsVoip
+                            ? mVoipCallFocusState : mSim2CallFocusState);	
+					}
                     return HANDLED;
                 case NEW_RINGING_CALL:
                     if (args.hasHoldingCalls) {
@@ -461,7 +571,8 @@
 
     private final BaseState mUnfocusedState = new UnfocusedState();
     private final BaseState mRingingFocusState = new RingingFocusState();
-    private final BaseState mSimCallFocusState = new SimCallFocusState();
+    private final BaseState mSim1CallFocusState = new Sim1CallFocusState();
+	private final BaseState mSim2CallFocusState = new Sim2CallFocusState();
     private final BaseState mVoipCallFocusState = new VoipCallFocusState();
     private final BaseState mOtherFocusState = new OtherFocusState();
 
@@ -478,7 +589,8 @@
 
         addState(mUnfocusedState);
         addState(mRingingFocusState);
-        addState(mSimCallFocusState);
+        addState(mSim1CallFocusState);
+		addState(mSim2CallFocusState);
         addState(mVoipCallFocusState);
         addState(mOtherFocusState);
         setInitialState(mUnfocusedState);
@@ -496,6 +608,14 @@
     }
 
     public void sendMessageWithArgs(int messageCode, MessageArgs args) {
+		int vsid1 = SystemProperties.getInt("gsm.current.vsid", 0);
+        int vsid2 = SystemProperties.getInt("gsm.current.vsid2", 0);
+        if(vsid1 == 1){
+			PHONE_ID = 0;
+		}
+        if(vsid2 == 1){
+			PHONE_ID = 1;
+		}
         sendMessage(messageCode, args);
     }
 
diff -ur a/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java b/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java
--- a/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java	Mon Jun 20 17:28:46 2016
+++ b/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java	Mon Jun 27 10:45:01 2016
@@ -62,6 +62,8 @@
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
+import java.io.FileOutputStream;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -134,6 +136,8 @@
     private WindowManagerInternal mWindowManagerInternal;
     private InputManagerInternal mInputManagerInternal;
     private IMediaProjectionManager mProjectionService;
+	
+	public static final String TS_PATH = "/sys/class/input/input3/enabled";
 
     // The synchronization root for the display manager.
     // This lock guards most of the display manager's state.
@@ -697,6 +701,36 @@
         }
         scheduleTraversalLocked(false);
     }
+	
+	 // Writes to sysfs node, returns true if success, false if fail
+     private boolean write_sysfs(String path, boolean on) {
+        try {
+            FileOutputStream fos = new FileOutputStream(path);
+            byte[] bytes = new byte[2];
+            bytes[0] = (byte)(on ? '1' : '0');
+            bytes[1] = '\n';
+            fos.write(bytes);
+            fos.close();
+        } catch (Exception e) {
+            Slog.i(TAG, "Fail: " + e.getLocalizedMessage());
+            return false;
+        }
+        return true;
+    }
+	
+	// Enables or disables input devices by writing to sysfs path
+    private void enableDevices(boolean enable) {
+        boolean ret;
+        if(enable) {
+            // Turn on touch input
+            ret = write_sysfs(TS_PATH, true);
+            Slog.i(TAG, "Enabled touchscreen, success? " + ret);
+        } else {
+            // Turn off touch input
+            ret = write_sysfs(TS_PATH, false);
+            Slog.i(TAG, "Disabled touchscreen, success? " + ret);
+        }
+    }
 
     private void handleDisplayDeviceChanged(DisplayDevice device) {
         synchronized (mSyncRoot) {
@@ -710,6 +744,14 @@
             if (diff == DisplayDeviceInfo.DIFF_STATE) {
                 Slog.i(TAG, "Display device changed state: \"" + info.name
                         + "\", " + Display.stateToString(info.state));
+						
+				if(info.state == Display.STATE_ON){
+					enableDevices(true);
+				}
+				if (info.state == Display.STATE_OFF) {
+					enableDevices(false);
+				}		
+						
             } else if (diff != 0) {
                 Slog.i(TAG, "Display device changed: " + info);
             }

diff -ur a/hardware/qcom/fm/fmapp2/src/com/caf/fmradio/FMRadioService.java b/hardware/qcom/fm/fmapp2/src/com/caf/fmradio/FMRadioService.java
--- a/hardware/qcom/fm/fmapp2/src/com/caf/fmradio/FMRadioService.java	Mon Jun 20 17:28:46 2016
+++ b/hardware/qcom/fm/fmapp2/src/com/caf/fmradio/FMRadioService.java	Mon Jun 27 10:45:01 2016
@@ -1066,14 +1066,25 @@
                mSpeakerPhoneOn = true;
                Log.d(LOGTAG, "Audio source set it as speaker");
                AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_SPEAKER);
+               mAudioManager.setParameters("fm_mode=on");
+               mAudioManager.setParameters("fm_radio_volume=on");
+               mAudioManager.setParameters("FMRadioVol=0.1496235728");
+               mAudioManager.setMode(AudioManager.MODE_IN_CALL);
+               mAudioManager.setSpeakerphoneOn(true);
            } else {
                Log.d(LOGTAG, "Audio source set it as headset");
                AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_NONE);
+			   mAudioManager.setParameters("fm_mode=on");
+               mAudioManager.setParameters("fm_radio_volume=on");
+               mAudioManager.setParameters("FMRadioVol=0.1496235728");
+               mAudioManager.setMode(AudioManager.MODE_IN_CALL);
+               mAudioManager.setSpeakerphoneOn(false);
            }
        } else {
                Log.d(LOGTAG, "A2DP is connected, set audio source to A2DP HS");
                AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_SPEAKER);
                mSpeakerPhoneOn = true;
+			   mAudioManager.setSpeakerphoneOn(true);
        }
 
        mPlaybackInProgress = true;
@@ -1090,6 +1101,8 @@
        Log.d(LOGTAG, "In stopFM");
        configureAudioDataPath(false);
        mPlaybackInProgress = false;
+	   mAudioManager.setParameters("fm_radio_mute=1");
+       mAudioManager.setParameters("fm_mode=off");
        try {
            if ((mServiceInUse) && (mCallbacks != null))
                mCallbacks.onFmAudioPathStopped();
@@ -1539,6 +1552,7 @@
       public void run() {
          Log.v(LOGTAG, "Disabling Speaker");
          AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_NONE);
+		 mAudioManager.setSpeakerphoneOn(false);
       }
    };
 
@@ -2257,6 +2271,7 @@
       if ( mSpeakerPhoneOn) {
           mSpeakerPhoneOn = false;
           AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_NONE);
+		  mAudioManager.setSpeakerphoneOn(false);
       }
    }
 
@@ -2376,10 +2391,12 @@
             } else {
                 Log.d(LOGTAG, "A2DP is not connected, force none");
                 AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_NONE);
+				mAudioManager.setSpeakerphoneOn(false);
             }
        } else if (speakerOn == true) {
            Log.d(LOGTAG, "enabling speaker");
            AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_SPEAKER);
+		   mAudioManager.setSpeakerphoneOn(true);
        }
 
        Log.d(LOGTAG, "speakerOn completed:" + speakerOn);
@@ -2480,6 +2497,7 @@
       {
          mMuted = true;
          audioManager.setParameters("fm_mute=1");
+		 audioManager.setParameters("fm_radio_mute=1");
          if (mAudioTrack != null)
              mAudioTrack.setVolume(0.0f);
       }
@@ -2502,6 +2520,7 @@
       {
          mMuted = false;
          audioManager.setParameters("fm_mute=0");
+		 audioManager.setParameters("fm_radio_mute=0");
          if (mAudioTrack != null)
              mAudioTrack.setVolume(1.0f);
          if (mResumeAfterCall)
		 
