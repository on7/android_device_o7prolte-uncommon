diff -ur a/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java b/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java
--- a/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java	Wed Apr 20 08:50:20 2016
+++ b/packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java	Thu May 12 01:31:40 2016
@@ -195,6 +195,7 @@
     private final PhoneStateBroadcaster mPhoneStateBroadcaster;
     private final CallLogManager mCallLogManager;
     private final Context mContext;
+    public  final Context pContext;
     private final TelecomSystem.SyncRoot mLock;
     private final ContactsAsyncHelper mContactsAsyncHelper;
     private final CallerInfoAsyncQueryFactory mCallerInfoAsyncQueryFactory;
@@ -255,6 +256,7 @@
             AsyncRingtonePlayer asyncRingtonePlayer,
             ViceNotifier viceNotifier) {
         mContext = context;
+        pContext = context;
         mLock = lock;
         mContactsAsyncHelper = contactsAsyncHelper;
         mCallerInfoAsyncQueryFactory = callerInfoAsyncQueryFactory;

diff -ur a/packages/services/Telecomm/src/com/android/server/telecom/CallAudioManager.java b/packages/services/Telecomm/src/com/android/server/telecom/CallAudioManager.java
--- a/packages/services/Telecomm/src/com/android/server/telecom/CallAudioManager.java	Wed Apr 20 08:50:20 2016
+++ b/packages/services/Telecomm/src/com/android/server/telecom/CallAudioManager.java	Thu May 12 01:31:40 2016
@@ -31,6 +31,27 @@
 import java.util.Set;
 import java.util.LinkedHashSet;
 
+import android.app.ActivityManagerNative;
+import android.content.Context;
+import android.content.pm.UserInfo;
+import android.media.AudioManager;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+
+import android.telecom.PhoneAccountHandle;
+import android.telephony.SubscriptionManager;
+
+import com.android.internal.util.Preconditions;
+
+import java.util.Objects;
+
 public class CallAudioManager extends CallsManagerListenerBase {
 
     public interface AudioServiceFactory {
@@ -57,6 +78,8 @@
     private boolean mIsTonePlaying = false;
     private InCallTonePlayer mHoldTonePlayer;
 
+    private AudioManager mAudioManager;
+
     public CallAudioManager(CallAudioRouteStateMachine callAudioRouteStateMachine,
             CallsManager callsManager,
             CallAudioModeStateMachine callAudioModeStateMachine,
@@ -84,10 +107,28 @@
         mRingbackPlayer = ringbackPlayer;
         mDtmfLocalTonePlayer = dtmfLocalTonePlayer;
 
+        mAudioManager = (AudioManager) mCallsManager.pContext.getSystemService(Context.AUDIO_SERVICE);
+
         mPlayerFactory.setCallAudioManager(this);
         mCallAudioModeStateMachine.setCallAudioManager(this);
     }
 
+    private int getPhoneId(Call call) {
+         if (call.getTargetPhoneAccount() != null) {
+             PhoneAccountHandle account = call.getTargetPhoneAccount();
+            try {
+                 int index = Integer.parseInt(account.getId());
+                 int phoneId = SubscriptionManager.getPhoneId(index);
+                 if (SubscriptionManager.isValidPhoneId(phoneId)) {
+                     return phoneId;
+                 }
+             } catch (NumberFormatException e) {
+                 Log.e(this, e, "Cannot get phoneId from ID value " + account.getId());
+             }
+         }
+         return -1;
+     }
+
     @Override
     public void onCallStateChanged(Call call, int oldState, int newState) {
         if (shouldIgnoreCallForAudio(call)) {
@@ -458,11 +499,28 @@
                 makeArgsForModeStateMachine());
     }
 
+    private void setMSIMAudioState(boolean enable) {
+        if(enable){
+            mAudioManager.setParameters("realcall=on");
+            Call callm = getForegroundCall();
+            int phoneId = getPhoneId(callm);
+            if (phoneId == 0) {
+                mAudioManager.setParameters("phone_type=cp1");
+            } else if (phoneId == 1) {
+                mAudioManager.setParameters("phone_type=cp2");
+            }
+			mCallAudioRouteStateMachine.sendMessageWithSessionInfo(CallAudioRouteStateMachine.USER_SWITCH_EARPIECE);
+        }else{
+             /* mAudioManager.setParameters("realcall=off"); */
+        } 
+    }
+
     private void onCallLeavingState(Call call, int state) {
         switch (state) {
             case CallState.ACTIVE:
             case CallState.CONNECTING:
                 onCallLeavingActiveDialingOrConnecting();
+                setMSIMAudioState(false);
                 break;
             case CallState.RINGING:
                 onCallLeavingRinging();
@@ -481,6 +539,7 @@
             case CallState.ACTIVE:
             case CallState.CONNECTING:
                 onCallEnteringActiveDialingOrConnecting();
+                setMSIMAudioState(true);
                 break;
             case CallState.RINGING:
                 onCallEnteringRinging();

diff -ur a/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java b/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java
--- a/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java	Mon Jun 20 17:28:46 2016
+++ b/frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java	Mon Jun 27 10:45:01 2016
@@ -62,6 +62,8 @@
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
+import java.io.FileOutputStream;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -134,6 +136,8 @@
     private WindowManagerInternal mWindowManagerInternal;
     private InputManagerInternal mInputManagerInternal;
     private IMediaProjectionManager mProjectionService;
+	
+	public static final String TS_PATH = "/sys/class/input/input3/enabled";
 
     // The synchronization root for the display manager.
     // This lock guards most of the display manager's state.
@@ -697,6 +701,36 @@
         }
         scheduleTraversalLocked(false);
     }
+	
+	 // Writes to sysfs node, returns true if success, false if fail
+     private boolean write_sysfs(String path, boolean on) {
+        try {
+            FileOutputStream fos = new FileOutputStream(path);
+            byte[] bytes = new byte[2];
+            bytes[0] = (byte)(on ? '1' : '0');
+            bytes[1] = '\n';
+            fos.write(bytes);
+            fos.close();
+        } catch (Exception e) {
+            Slog.i(TAG, "Fail: " + e.getLocalizedMessage());
+            return false;
+        }
+        return true;
+    }
+	
+	// Enables or disables input devices by writing to sysfs path
+    private void enableDevices(boolean enable) {
+        boolean ret;
+        if(enable) {
+            // Turn on touch input
+            ret = write_sysfs(TS_PATH, true);
+            Slog.i(TAG, "Enabled touchscreen, success? " + ret);
+        } else {
+            // Turn off touch input
+            ret = write_sysfs(TS_PATH, false);
+            Slog.i(TAG, "Disabled touchscreen, success? " + ret);
+        }
+    }
 
     private void handleDisplayDeviceChanged(DisplayDevice device) {
         synchronized (mSyncRoot) {
@@ -710,6 +744,14 @@
             if (diff == DisplayDeviceInfo.DIFF_STATE) {
                 Slog.i(TAG, "Display device changed state: \"" + info.name
                         + "\", " + Display.stateToString(info.state));
+						
+				if(info.state == Display.STATE_ON){
+					enableDevices(true);
+				}
+				if (info.state == Display.STATE_OFF) {
+					enableDevices(false);
+				}		
+						
             } else if (diff != 0) {
                 Slog.i(TAG, "Display device changed: " + info);
             }

diff -ur a/hardware/qcom/fm/fmapp2/src/com/caf/fmradio/FMRadioService.java b/hardware/qcom/fm/fmapp2/src/com/caf/fmradio/FMRadioService.java
--- a/hardware/qcom/fm/fmapp2/src/com/caf/fmradio/FMRadioService.java	Mon Jun 20 17:28:46 2016
+++ b/hardware/qcom/fm/fmapp2/src/com/caf/fmradio/FMRadioService.java	Mon Jun 27 10:45:01 2016
@@ -1066,14 +1066,25 @@
                mSpeakerPhoneOn = true;
                Log.d(LOGTAG, "Audio source set it as speaker");
                AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_SPEAKER);
+               mAudioManager.setParameters("fm_mode=on");
+               mAudioManager.setParameters("fm_radio_volume=on");
+               mAudioManager.setParameters("FMRadioVol=0.1496235728");
+               mAudioManager.setMode(AudioManager.MODE_IN_CALL);
+               mAudioManager.setSpeakerphoneOn(true);
            } else {
                Log.d(LOGTAG, "Audio source set it as headset");
                AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_NONE);
+			   mAudioManager.setParameters("fm_mode=on");
+               mAudioManager.setParameters("fm_radio_volume=on");
+               mAudioManager.setParameters("FMRadioVol=0.1496235728");
+               mAudioManager.setMode(AudioManager.MODE_IN_CALL);
+               mAudioManager.setSpeakerphoneOn(false);
            }
        } else {
                Log.d(LOGTAG, "A2DP is connected, set audio source to A2DP HS");
                AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_SPEAKER);
                mSpeakerPhoneOn = true;
+			   mAudioManager.setSpeakerphoneOn(true);
        }
 
        mPlaybackInProgress = true;
@@ -1090,6 +1101,8 @@
        Log.d(LOGTAG, "In stopFM");
        configureAudioDataPath(false);
        mPlaybackInProgress = false;
+	   mAudioManager.setParameters("fm_radio_mute=1");
+       mAudioManager.setParameters("fm_mode=off");
        try {
            if ((mServiceInUse) && (mCallbacks != null))
                mCallbacks.onFmAudioPathStopped();
@@ -1539,6 +1552,7 @@
       public void run() {
          Log.v(LOGTAG, "Disabling Speaker");
          AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_NONE);
+		 mAudioManager.setSpeakerphoneOn(false);
       }
    };
 
@@ -2257,6 +2271,7 @@
       if ( mSpeakerPhoneOn) {
           mSpeakerPhoneOn = false;
           AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_NONE);
+		  mAudioManager.setSpeakerphoneOn(false);
       }
    }
 
@@ -2376,10 +2391,12 @@
             } else {
                 Log.d(LOGTAG, "A2DP is not connected, force none");
                 AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_NONE);
+				mAudioManager.setSpeakerphoneOn(false);
             }
        } else if (speakerOn == true) {
            Log.d(LOGTAG, "enabling speaker");
            AudioSystem.setForceUse(AudioSystem.FOR_MEDIA, AudioSystem.FORCE_SPEAKER);
+		   mAudioManager.setSpeakerphoneOn(true);
        }
 
        Log.d(LOGTAG, "speakerOn completed:" + speakerOn);
@@ -2480,6 +2497,7 @@
       {
          mMuted = true;
          audioManager.setParameters("fm_mute=1");
+		 audioManager.setParameters("fm_radio_mute=1");
          if (mAudioTrack != null)
              mAudioTrack.setVolume(0.0f);
       }
@@ -2502,6 +2520,7 @@
       {
          mMuted = false;
          audioManager.setParameters("fm_mute=0");
+		 audioManager.setParameters("fm_radio_mute=0");
          if (mAudioTrack != null)
              mAudioTrack.setVolume(1.0f);
          if (mResumeAfterCall)

diff --git a/frameworks/av/camera/cameraserver/Android.mk b/frameworks/av/camera/cameraserver/Android.mk
--- a/frameworks/av/camera/cameraserver/Android.mk
+++ b/frameworks/av/camera/cameraserver/Android.mk
@@ -14,6 +14,7 @@
 
 LOCAL_PATH:= $(call my-dir)
 
+ifneq ($(TARGET_HAS_LEGACY_CAMERA_HAL1),true)
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:= \
@@ -34,3 +35,4 @@
 LOCAL_INIT_RC := cameraserver.rc
 
 include $(BUILD_EXECUTABLE)
+endif
diff --git a/frameworks/av/media/mediaserver/Android.mk b/frameworks/av/media/mediaserver/Android.mk
--- a/frameworks/av/media/mediaserver/Android.mk
+++ b/frameworks/av/media/mediaserver/Android.mk
@@ -39,6 +39,10 @@
     LOCAL_CFLAGS += -DMAX_CAMERAS=$(BOARD_NUMBER_OF_CAMERAS)
 endif
 
+ifeq ($(TARGET_HAS_LEGACY_CAMERA_HAL1),true)
+    LOCAL_CFLAGS += -DNO_CAMERA_SERVER
+endif
+
 LOCAL_MODULE:= mediaserver
 LOCAL_32_BIT_ONLY := true
 
diff --git a/media/mediaserver/main_mediaserver.cpp b/media/mediaserver/main_mediaserver.cpp
--- a/frameworks/av/media/mediaserver/main_mediaserver.cpp
+++ b/frameworks/av/media/mediaserver/main_mediaserver.cpp
@@ -25,6 +25,9 @@
 #include "RegisterExtensions.h"
 
 // from LOCAL_C_INCLUDES
+#ifdef NO_CAMERA_SERVER
+#include "CameraService.h"
+#endif
 #include "IcuUtils.h"
 #include "MediaPlayerService.h"
 #include "ResourceManagerService.h"
@@ -41,6 +44,9 @@
     InitializeIcuOrDie();
     MediaPlayerService::instantiate();
     ResourceManagerService::instantiate();
+#ifdef NO_CAMERA_SERVER
+    CameraService::instantiate();
+#endif
     registerExtensions();
     ProcessState::self()->startThreadPool();
     IPCThreadState::self()->joinThreadPool();
diff --git a/services/camera/libcameraservice/Android.mk b/services/camera/libcameraservice/Android.mk
--- a/frameworks/av/services/camera/libcameraservice/Android.mk
+++ b/frameworks/av/services/camera/libcameraservice/Android.mk
@@ -83,6 +83,10 @@
     LOCAL_CFLAGS += -DMAX_CAMERAS=$(BOARD_NUMBER_OF_CAMERAS)
 endif
 
+ifeq ($(TARGET_HAS_LEGACY_CAMERA_HAL1),true)
+    LOCAL_CFLAGS += -DNO_CAMERA_SERVER
+endif
+
 LOCAL_MODULE:= libcameraservice
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/services/camera/libcameraservice/CameraService.cpp b/services/camera/libcameraservice/CameraService.cpp
--- a/frameworks/av/services/camera/libcameraservice/CameraService.cpp
+++ b/frameworks/av/services/camera/libcameraservice/CameraService.cpp
@@ -831,7 +831,11 @@
 Status CameraService::initializeShimMetadata(int cameraId) {
     int uid = getCallingUid();
 
+#ifdef NO_CAMERA_SERVER
+    String16 internalPackageName("media");
+#else
     String16 internalPackageName("cameraserver");
+#endif
     String8 id = String8::format("%d", cameraId);
     Status ret = Status::ok();
     sp<Client> tmp = nullptr;
@@ -912,7 +916,9 @@
 static bool isTrustedCallingUid(uid_t uid) {
     switch (uid) {
         case AID_MEDIA:         // mediaserver
+#ifndef NO_CAMERA_SERVER
         case AID_CAMERASERVER: // cameraserver
+#endif
             return true;
         default:
             return false;
		 